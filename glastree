#!/usr/bin/perl

#
# glastree -- build dated, versioned tree of sourcedir, usually per diem
#
#  Jeremy Wohl (http://igmus.org/code)
#  Public domain; no warranty, no responsibility, etc.
#
#  $Id: glastree,v 1.10 2001/11/28 05:32:18 jeremyw Exp $
#

require 5.002;

use English;
use DirHandle;
use File::Copy;
use File::stat;
use Date::Calc qw (Today Add_Delta_Days);
use strict;

# some globals
my ($source, $target, $today, $yesterday);

main ();

sub main
{
    if (not defined @ARGV or scalar @ARGV < 2)
    {
	print STDERR "usage: glastree sourcedir backupdir\n\n";
	#print STDERR "  -d n        Prune days (or directories) more than n back\n";
	#print STDERR "  -i          Use hour/minute in directory names, suppress per diem\n";
	exit 1;
    }

    $source = $ARGV [0];
    $target = $ARGV [1];

    $today     = sprintf "%4d/%02d/%02d", Today ();
    $yesterday = sprintf "%4d/%02d/%02d", Add_Delta_Days (Today (), -1);

    die "fatal: $target or $source does not exist"            if not -e $target or not -e $source;
    die "fatal: $target or $source is not a directory"        if not -d $target or not -d $source;
    die "fatal: $target/$today already exists"                if     -e "$target/$today";
    die "fatal: you do not have read permission in $source"   if not -r $source;
    die "fatal: you do not have write permission in $target"  if not -w $target;
    die "fatal: backupdir is the same as sourcedir"           if $target eq $source;

    rmkdir ("$target/$today");

    recurse ($source);
}


sub recurse
{
    my ($cwd) = shift;
    my ($dir, @list, @dirs, @files);
    my ($file, $num);
    my ($now_stat, $yes_stat);


    mkdirstat ("$target/$today", $cwd);
    
    return if ($dir = new DirHandle ($cwd)) == undef;

    @list  = $dir->read;
    @dirs  = grep { /^[^\.]/ && -d "$cwd/$_" } @list;
    @files = grep {             -f "$cwd/$_" } @list;
    undef $dir;

    # for all files in the source tree
    #   if the file is a link, make the link
    #   else if the file is a dir, make the dir
    #   else if the file is a normal file
    #     if yesterday does not exist or today is newer, copy the file
    #     else hard link the file to yesterday
    #   else: no logic to handle file type
    # end

    foreach $file (@files)
    {
	my $new_path       = "$cwd/$file";
	my $today_path     = "$target/$today/$cwd/$file";
	my $yesterday_path = "$target/$yesterday/$cwd/$file";

	if (-l $new_path) {
	    symlink (readlink ($new_path), $today_path);
	}

	elsif (-f $new_path)
	{
	    my $new_stat       = stat $new_path;
	    my $yesterday_stat = stat $yesterday_path;

	    if (not defined ($yesterday_stat)
		or $new_stat->mtime != $yesterday_stat->mtime
		or $new_stat->size  != $yesterday_stat->size)
	    {
		copystat ($new_path, $today_path, $new_stat);
	    }
	    else {
		link ($yesterday_path, $today_path);
	    }
	}	    

	else {
	    print STDERR "warning: no logic to handle $cwd/$file; skipping\n";
	}
    }

    foreach (@dirs) { recurse ("$cwd/$_"); }
}


sub mkdirstat ($prefix, $path)
{
    my ($prefix, $path) = @_;
    my ($piece, $olddir, $newdir, $fulldir, $stat);

    foreach $piece (split '/', $path)
    {
	$olddir .= ($piece eq "" ? "/" : "") . $piece . "/";
	$newdir .= $piece . "/";
	$fulldir = "$prefix/$newdir";

	if (not -e $fulldir)
	{
	    $stat = stat $olddir;

	    mkdir $fulldir, 0755;
	    chown ($stat->uid, $stat->gid, $fulldir) if $EUID == 0;
	    chmod ($stat->mode, $fulldir);
	    utime ($stat->mtime, $stat->mtime, $fulldir);
	}
    }
}


sub copystat ($frompath, $topath, $stat)
{
    my ($frompath, $topath, $stat) = @_;

    copy  ($frompath, $topath);
    chown ($stat->uid, $stat->gid, $topath) if $EUID == 0;
    chmod ($stat->mode, $topath);
    utime ($stat->mtime, $stat->mtime, $topath);
}


#
# Make all segments of $path that do not exist
#
#
sub rmkdir ($path)
{
    my ($path) = shift;
    my ($piece, $newdir);

    foreach $piece (split '/', $path) {
	next if $piece eq "";
	$newdir .= "/" . $piece;
	mkdir $newdir, 0700 if not -e $newdir;
    }
}
